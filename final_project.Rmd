---
title: "Big Data Final project"
author: "Summer Negahdar"
date: "2025-03-09"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


```{r}
install.packages("googledrive")
library(googledrive)
library(ggplot2)
library(tidyverse)
library(dplyr)
library(jsonlite)
library(purrr)
```


```{r}
file_id <- "13UHRy_cf_5zsLKj1tgCHQFm8OwHfiQSe"

# Download the CSV file
drive_download(as_id(file_id), path = "playlist.csv", overwrite = TRUE)
playlist_df<- read.csv("playlist.csv")

##uploading spotify songs dataset
song_df<- read_csv('spotify_songs.csv')
```

```{r}
### playlist df
##just looking at statistical
summary(playlist_df)
#looking at columns
colnames(playlist_df)
```

```{r}
##creating a boxplot of num_tracks column to see how many tracks are there in average
# Create a boxplot
# Create the boxplot
ggplot(playlist_df) +
  geom_boxplot(aes(x = "number of samples", y = num_samples), width = 0.2) +
  geom_boxplot(aes(x = "number of tracks", y = num_tracks), width = 0.2) +
  labs(title = "Boxplots of num_samples and num_tracks", x = "Category", y = "Values") +
  theme_minimal() +
  theme(axis.text.x = element_text(hjust = 1))
```
there is a large number of variables where the number of samples is too small. we don't want that so we create a subset where number of samples is mode or larger!

```{r}
# Subset the dataset
playlist_subset <- playlist_df %>%
  filter(num_samples >= 10)

# View the first few rows
head(playlist_subset)
```

```{r}
# Function to clean and fix JSON format by replacing single quotes with double quotes
clean_json <- function(json_text) {
  # Replace single quotes with double quotes to make the JSON valid
  json_text <- gsub("'", '"', json_text)
  
  # Optionally escape any problematic characters if needed
  json_text <- gsub('(?<!\\\\)"', '\\"', json_text, perl = TRUE)
  
  return(json_text)
}

# Apply the cleaning function and parse the JSON
playlist_subset_fixed <- playlist_subset
playlist_subset_fixed$tracks <- lapply(playlist_subset_fixed$tracks, clean_json)  # Clean the JSON format

# Function to parse the cleaned JSON manually without external libraries
parse_json <- function(json_text) {
  # Attempt to parse the JSON text
  parsed <- tryCatch({
    json_data <- jsonlite::fromJSON(json_text)
    as.data.frame(json_data)
  }, error = function(e) {
    message("Error parsing JSON: ", e$message)
    return(NULL)
  })
  
  return(parsed)
}

# Apply the JSON parsing function and clean up the list
playlist_subset_fixed$tracks <- lapply(playlist_subset_fixed$tracks, parse_json)

# Flatten the list of tracks and filter out "Frank's Track"
playlist_subset_fixed <- do.call(rbind, playlist_subset_fixed$tracks)
playlist_subset_fixed <- playlist_subset_fixed[playlist_subset_fixed$track_name != "Frank\"s Track", ]

# Inspect the result
head(playlist_subset_fixed)
```
```{r}
## i will be extracting track ids from track_uri column so I can merge it with songs_df
# Replace track_uri with track_id by extracting the ID
playlist_subset_fixed <- playlist_subset_fixed %>%
  mutate(track_id = sub("spotify:track:", "", track_uri)) %>%
  select(-track_uri)  # Remove the original track_uri column
head(playlist_subset_fixed$track_id)
```
```{r}
# Get unique track names from playlist_subset_fixed
playlist_track_names <- unique(playlist_subset_fixed$track_name)

# Get unique track names from song_df
song_df_track_names <- unique(song_df$track_name)

# Find matching track names
matching_track_names <- playlist_track_names[playlist_track_names %in% song_df_track_names]
num_matches <- length(matching_track_names)

# Total number of unique track names in each dataset
total_playlist_track_names <- length(playlist_track_names)
total_song_df_track_names <- length(song_df_track_names)

# Print the results
cat("Number of unique track names in playlist_subset_fixed:", total_playlist_track_names, "\n")
cat("Number of unique track names in song_df:", total_song_df_track_names, "\n")
cat("Number of track names from playlist_subset_fixed that match song_df:", num_matches, "\n")
cat("Percentage of playlist_subset_fixed track names found in song_df:", 
    round(num_matches / total_playlist_track_names * 100, 2), "%\n")
##we have 2015 songs whose data we can find in songs-df
```
```{r}
# Get unique track IDs from playlist_subset_fixed and playlist_df
playlist_subset_fixed_track_ids <- unique(playlist_subset_fixed$track_id)
playlist_df_track_ids <- unique(song_df$track_id)

# Find matching track IDs
matching_track_ids <- playlist_subset_fixed_track_ids[playlist_subset_fixed_track_ids %in% playlist_df_track_ids]
num_matches_ids <- length(matching_track_ids)

# Total number of unique track IDs in each dataset
total_playlist_subset_fixed_track_ids <- length(playlist_subset_fixed_track_ids)
total_playlist_df_track_ids <- length(playlist_df_track_ids)

# Print the results
cat("Number of unique track IDs in playlist_subset_fixed:", total_playlist_subset_fixed_track_ids, "\n")
cat("Number of unique track IDs in song_df:", total_playlist_df_track_ids, "\n")
cat("Number of track IDs from playlist_subset_fixed that match song_df:", num_matches_ids, "\n")
cat("Percentage of playlist_subset_fixed track IDs found in song_df:", 
    round(num_matches_ids / total_playlist_subset_fixed_track_ids * 100, 2), "%\n")

# Optionally, display the matching track IDs
if (num_matches_ids > 0) {
  cat("Matching track IDs:\n", paste(matching_track_ids, collapse = "\n"), "\n")
} else {
  cat("No matching track IDs found.\n")
}

# Find matching track names from the matching track IDs
matching_track_names_by_id <- playlist_subset_fixed$track_name[playlist_subset_fixed$track_id %in% matching_track_ids]

```
## Conclusion

there are songs that have similar name but IDs ar different! we will focus on IDs then!
